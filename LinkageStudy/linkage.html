<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="UTF-8">
  <title>Linkage: 3-Point Circle, Radius, and Link Drawings</title>
  <style>
    body { font-family: sans-serif; padding: 0 20px; }

    label { 
        margin-right: 10px;
        margin-bottom: 10px;
        display: block; 
    }

    .label-text {
        width: 80px;
        display: inline-block;
        font-weight: 600;
    }

    .label-text.symbol {
        font-style: italic;
    }

    .slider-container {
      position: relative;
      width:300px;
      margin-top: 15px;
      display: inline-block;
    }
    
    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 6px;
      background: #ddd;
      border-radius: 5px;
      outline: none;
      display: inline-block;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background-color: #1abc9c;
      border-radius: 50%;
      cursor: pointer;
      position: relative;
      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.4);
      z-index: 2;
    }

    .slider-value, .slider-min, .slider-max {
      position: absolute;
      top: -22px;
      color: white;
      padding: 3px 6px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
    }

    .slider-value {
      background-color: #1abc9c;
      color: white;
      transform: translateX(-50%);
      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.4);
      z-index: 3;
    }

    .slider-value::after {
        position: absolute;
        content: '';
        left: 0;
        border-radius: 14px;
        top: 14px;
        border-left: 14px solid transparent;
        border-right: 14px solid transparent;
        border-top-width: 10px;
        border-top-style: solid;
        border-top-color: #1ABC9C;
    }

    .slider-min, .slider-max {
      background: #777;
      color: #fff;
      z-index: 1;
    }

    .slider-min { left: 0%; transform: translateX(-3px); }
    .slider-max { left: 100%; transform: translateX(-89%); }

    .double-slider {
        display: inline-block;
    }

    .double-slider > .slider-container {
      width:162px;
      margin-top: 15px;
      display: inline-block;
    }

    .double-slider > .slider-container.max {
        margin-left: -12px;
    }

    .double-slider > .slider-container.min {
        margin-right: -12px;
    }

    .double-slider .slider-max {
        transform: translateX(-82%);
    }

    #canvas { 
        border: 1px solid black; 
        margin-top: 20px; 
        box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.4);
    }
  </style>
</head>
<body>
  <h1>Linkage Study: Double Action</h1>
  <div>
    <label><span class="label-text">Radius:</span> 
        <div class="slider-container">
            <input type="range" id="radius" min="12" max="30" value="17" class="slider">
            <span class="slider-min"></span>
            <span class="slider-value"></span>
            <span class="slider-max"></span>
        </div>
    </label>
    <label><span class="label-text symbol">p:</span>
        <div class="slider-container">
            <input type="range" id="p" min="20" max="70" value="28" class="slider">
            <span class="slider-min"></span>
            <span class="slider-value"></span>
            <span class="slider-max"></span>
        </div>
    </label>
    <label><span class="label-text symbol">q:</span> 
        <div class="slider-container">
            <input type="range" id="q" min="20" max="70" value="42" class="slider">
            <span class="slider-min"></span>
            <span class="slider-max"></span>
            <span class="slider-value"></span>
        </div>
    </label>
    <label><span class="label-text">Range (°):</span>
        <div class="double-slider">
            <div class="slider-container min">
                <input type="range" id="minAngle" min="60" max="89" value="60" step="5" class="slider">
                <span class="slider-min"></span>
                <span class="slider-value"></span>
            </div>
            <div class="slider-container max">
                <input type="range" id="maxAngle" min="90" max="120" value="120" step="5" class="slider">
                <span class="slider-value"></span>
                <span class="slider-max"></span>
            </div>
        </div>
    </label>
  </div>
  <canvas id="canvas" width="800" height="500"></canvas>

  <script>
    /**
     * Calculate the coupler point C for angles from min to max (degrees)
     * with increment inc, using:
     *   A = (R cosθ, R sinθ) and B = (R cosθ, -R sinθ).
     * C is the intersection of:
     *    • Circle centered at A with radius p, and 
     *    • Circle centered at B with radius q.
     *
     * Derived formulas:
     *    y = (q² - p²) / (4 * R * sinθ)
     *    x = R cosθ + sqrt(p² - (y - R sinθ)²)
     */
    function calculateXY(radius, p, q, min, max, inc = 5) {
      let points = [];
      for (let theta = min; theta <= max; theta += inc) {
        let thetaRad = theta * Math.PI / 180;
        let A_x = radius * Math.cos(thetaRad);
        let A_y = radius * Math.sin(thetaRad);

        let sinTheta = Math.sin(thetaRad);
        if (Math.abs(sinTheta) < 1e-6) {
          points.push([null, null]);
          continue;
        }
        let y = (q * q - p * p) / (4 * radius * sinTheta);
        let diff = y - A_y;
        let radicand = p * p - diff * diff;
        if (radicand < 0) {
          points.push([null, null]);
        } else {
          let x = A_x + Math.sqrt(radicand);
          points.push([x, y]);
        }
      }
      return points;
    }

    /**
     * Given an array of points [ [x,y], ... ],
     * pick the first, middle, and last valid points and compute
     * the unique circle through them.
     * Returns { cx, cy, r, p1, p2, p3 } or null.
     */
    function circleThrough3Points(points) {
      let validPoints = points.filter(p => p[0] !== null && p[1] !== null);
      let n = validPoints.length;
      if (n < 3) return null;

      let p1 = validPoints[0];
      let p3 = validPoints[n - 1];
      let midIndex = Math.ceil(n / 2) - 1;  // 0-based
      let p2 = validPoints[midIndex];

      const [x1, y1] = p1;
      const [x2, y2] = p2;
      const [x3, y3] = p3;

      const D = 2 * (
        x1 * (y2 - y3) +
        x2 * (y3 - y1) +
        x3 * (y1 - y2)
      );
      if (Math.abs(D) < 1e-12) {
        return null;
      }

      const x1sq = x1*x1 + y1*y1;
      const x2sq = x2*x2 + y2*y2;
      const x3sq = x3*x3 + y3*y3;

      const cx = (
        x1sq * (y2 - y3) +
        x2sq * (y3 - y1) +
        x3sq * (y1 - y2)
      ) / D;

      const cy = (
        x1sq * (x3 - x2) +
        x2sq * (x1 - x3) +
        x3sq * (x2 - x1)
      ) / D;

      const r = Math.sqrt((x1 - cx)**2 + (y1 - cy)**2);

      return { cx, cy, r, p1, p2, p3 };
    }

    // Transform mechanism (x,y) to canvas coordinates, with (0,0) at canvas center.
    function transform(x, y, scale, cw, ch) {
      const canvasX = cw / 2 + x * scale;
      const canvasY = ch / 2 - y * scale;
      return { canvasX, canvasY };
    }

    // Draw grid lines every 10 mechanism units.
    function drawGrid(ctx, scale, cw, ch) {
      let x_min = -cw / 2 / scale;
      let x_max = cw / 2 / scale;
      let y_min = -ch / 2 / scale;
      let y_max = ch / 2 / scale;

      let startX = Math.ceil(x_min / 10) * 10;
      let endX   = Math.floor(x_max / 10) * 10;
      let startY = Math.ceil(y_min / 10) * 10;
      let endY   = Math.floor(y_max / 10) * 10;

      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 1;

      for (let x = startX; x <= endX; x += 10) {
        let p1 = transform(x, y_min, scale, cw, ch);
        let p2 = transform(x, y_max, scale, cw, ch);
        ctx.beginPath();
        ctx.moveTo(p1.canvasX, p1.canvasY);
        ctx.lineTo(p2.canvasX, p2.canvasY);
        ctx.stroke();
      }
      for (let y = startY; y <= endY; y += 10) {
        let p1 = transform(x_min, y, scale, cw, ch);
        let p2 = transform(x_max, y, scale, cw, ch);
        ctx.beginPath();
        ctx.moveTo(p1.canvasX, p1.canvasY);
        ctx.lineTo(p2.canvasX, p2.canvasY);
        ctx.stroke();
      }
    }

    // Main drawing function.
    function drawAll(points, radius, minAngle, maxAngle, p, q) {
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const cw = canvas.width, ch = canvas.height;
      const scale = 5;

      ctx.clearRect(0, 0, cw, ch);
      drawGrid(ctx, scale, cw, ch);

      // Draw the base circle (blue) at the origin with the given radius.
      let center0 = transform(0, 0, scale, cw, ch);
      ctx.beginPath();
      ctx.arc(center0.canvasX, center0.canvasY, 3, 0, 2 * Math.PI);
      ctx.strokeStyle = "#aaa";
      ctx.fillStyle = "#aaa";
      ctx.fill();
      ctx.stroke();

      const angles = [];
      for (let angle = minAngle; angle <= maxAngle; angle += 5) {
        let rad = angle * Math.PI / 180;
        let x = radius * Math.cos(rad);
        let y = radius * Math.sin(rad);
        let up = transform(x, y, scale, cw, ch);
        let lo = transform(x, -y, scale, cw, ch);
        angles.push({ up, lo });
      }

      let maxMark = angles.at(-1);
      ctx.beginPath();
      ctx.moveTo(center0.canvasX, center0.canvasY);
      ctx.lineTo(maxMark.up.canvasX, maxMark.up.canvasY);
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(center0.canvasX, center0.canvasY);
      ctx.lineTo(maxMark.lo.canvasX, maxMark.lo.canvasY);
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(center0.canvasX, center0.canvasY, radius * scale, 0, 2 * Math.PI);
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 2;
      ctx.stroke();

      angles.forEach(angle => {
        ctx.beginPath();
        ctx.arc(angle.up.canvasX, angle.up.canvasY, 3, 0, 2 * Math.PI);
        ctx.fillStyle = "green";
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(angle.lo.canvasX, angle.lo.canvasY, 3, 0, 2 * Math.PI);
        ctx.fillStyle = "green";
        ctx.fill();
        ctx.stroke();
      });

      // Draw coupler points (red).
      points.forEach(pt => {
        if (pt[0] === null || pt[1] === null) return;
        let { canvasX, canvasY } = transform(pt[0], pt[1], scale, cw, ch);
        ctx.beginPath();
        ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
        ctx.fillStyle = "red";
        ctx.fill();
        ctx.stroke();
      });

      // Compute the circle through the first, middle, and last valid points.
      let c3 = circleThrough3Points(points);
      if (c3) {
        let { cx, cy, r, p3 } = c3;
        // Draw the best-fit circle (purple, dashed).
        let cxy = transform(cx, cy, scale, cw, ch);
        ctx.beginPath();
        ctx.setLineDash([5, 3]);
        ctx.arc(cxy.canvasX, cxy.canvasY, r * scale, 0, 2 * Math.PI);
        ctx.strokeStyle = "purple";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw center of the best-fit circle.
        ctx.beginPath();
        ctx.arc(cxy.canvasX, cxy.canvasY, 3, 0, 2 * Math.PI);
        ctx.fillStyle = "purple";
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "purple";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(`(${cx.toFixed(1)}, ${cy.toFixed(1)})`, cxy.canvasX, cxy.canvasY - 10);

        // Draw a radius line from the circle's center to the last (p3) of the 3 chosen points.
        let lastPointCanvas = transform(p3[0], p3[1], scale, cw, ch);
        ctx.beginPath();
        ctx.moveTo(cxy.canvasX, cxy.canvasY);
        ctx.lineTo(lastPointCanvas.canvasX, lastPointCanvas.canvasY);
        ctx.strokeStyle = "purple";
        ctx.lineWidth = 1;
        ctx.stroke();

        // Label the radius near the midpoint of that line.
        let midRX = (cxy.canvasX + lastPointCanvas.canvasX) / 2;
        let midRY = (cxy.canvasY + lastPointCanvas.canvasY) / 2;
        ctx.fillStyle = "purple";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "start";
        ctx.fillText(`r = ${r.toFixed(1)}`, midRX + 5, midRY + 5);

        // --- Draw the link segments for p and q from the last pivot positions ---
        // For the last angle (maxAngle), compute pivot positions A and B:
        let thetaLast = maxAngle * Math.PI / 180;
        let A_last = [radius * Math.cos(thetaLast), radius * Math.sin(thetaLast)];
        let B_last = [radius * Math.cos(thetaLast), -radius * Math.sin(thetaLast)];

        let pivotA = transform(A_last[0], A_last[1], scale, cw, ch);
        let pivotB = transform(B_last[0], B_last[1], scale, cw, ch);
        let couplerLast = transform(p3[0], p3[1], scale, cw, ch);

        // Draw line from pivot A to last coupler point (represents link p).
        ctx.beginPath();
        ctx.moveTo(pivotA.canvasX, pivotA.canvasY);
        ctx.lineTo(couplerLast.canvasX, couplerLast.canvasY);
        ctx.strokeStyle = "#1abc9c";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw line from pivot B to last coupler point (represents link q).
        ctx.beginPath();
        ctx.moveTo(pivotB.canvasX, pivotB.canvasY);
        ctx.lineTo(couplerLast.canvasX, couplerLast.canvasY);
        ctx.strokeStyle = "#1abc9c";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Label the links with p and q near the midpoints.
        let midAP = { canvasX: (pivotA.canvasX + couplerLast.canvasX) / 2, canvasY: (pivotA.canvasY + couplerLast.canvasY) / 2 };
        let midBP = { canvasX: (pivotB.canvasX + couplerLast.canvasX) / 2, canvasY: (pivotB.canvasY + couplerLast.canvasY) / 2 };
        ctx.fillStyle = "#1abc9c";
        ctx.font = "14px sans-serif";
        ctx.fillText(`p = ${p}`, midAP.canvasX + 5, midAP.canvasY - 8);
        ctx.fillText(`q = ${q}`, midBP.canvasX + 5, midBP.canvasY + 16);
      }
    }

    function onValueChanged() {
      const radius = parseFloat(document.getElementById("radius").value);
      const p = parseFloat(document.getElementById("p").value);
      const q = parseFloat(document.getElementById("q").value);
      const minAngle = parseFloat(document.getElementById("minAngle").value);
      const maxAngle = parseFloat(document.getElementById("maxAngle").value);

      const points = calculateXY(radius, p, q, minAngle, maxAngle);
      drawAll(points, radius, minAngle, maxAngle, p, q);
    }

    const sliders = document.querySelectorAll('.slider');

    function updateSliderValue(slider) {
        const valueLabel = slider.parentElement.querySelector('.slider-value');
        const percent = (slider.value - slider.min) / (slider.max - slider.min);
        const sliderWidth = slider.offsetWidth;
        const thumbOffset = 20 * (0.5 - percent); // 20px = thumb width

        valueLabel.textContent = slider.value;
        valueLabel.style.left = `calc(${percent * 100}% + ${thumbOffset}px)`;
        onValueChanged();
    }

    sliders.forEach(slider => {
        const container = slider.parentElement;
        const minLabel = container.querySelector('.slider-min');
        const maxLabel = container.querySelector('.slider-max');
        if (minLabel)
            minLabel.textContent = slider.min;
        if (maxLabel)
            maxLabel.textContent = slider.max;
        updateSliderValue(slider); // initial setup
        slider.addEventListener('input', () => updateSliderValue(slider));
        window.addEventListener('resize', () => updateSliderValue(slider));
    });
  </script>
</body>
</html>
